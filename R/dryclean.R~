#' @import GenomicRanges
#' @import data.table
#' @import rsvd
#' @import gUtils
#' @import Matrix
#' @import stats

##############################
## thresh
##############################
#' @name thresh
#'
#' @title Internal shrinkage function for values in S vector
#' @description Internal shrinkage function for values in S vector:
#' y = sgn(x)max(|x| - mu, 0)
#' @keywords internal
#' @param x vector to which shrinkage is to applied
#' @param mu shrinkage parameter
#' @return regularized vector y

thresh = function(x, mu){
    y = pmax(x - mu, 0, na.rm = TRUE)
    y = y + pmin(x + mu, 0, na.rm = TRUE)
    return(y)}


##############################
## apg_project
##############################
#' @name apg_progect
#'
#' @title Accelerated Proximal Gradient based projection method
#' @description project new sample into the burnin space
#' solving projection by Accelerated Proximal Gradient
#' min_{v, s} 0.5*|m-Uv-s|_2^2 + 0.5*lambda1*|v|^2 + lambda2*|s|_1
#' @keywords internal
#' @param m.vec vector of GC corrected coverage data of sample in question
#' @param U the basis of low rank subspace
#' @param lambda1 tuning parameter
#' @param lambda2 tuning parameter
#' @return list with s and v vectors 


apg_project = function(m.vec, U, lambda1, lambda2){
    q = dim(U)[1]
    p = dim(U)[2]
    v = matrix(0, p, 1)
    s = matrix(0, q, 1)
    I = diag(p)
    converged = FALSE
    k = 0
    maxiter = 200
    UUt = (ginv(crossprod(U) + lambda1*I) %*% t(U))
    while (converged == FALSE){
        k =  k + 1
        message("on ", k)
        v.old = v
        ### v = (crossprod(U) + lambda1*I)/(crossprod(U, (m.vec - s))
        v = UUt %*% (m.vec - s)
        s.old = s
        s = thresh(m.vec - (U %*% v), lambda2)
        print(norm(v - v.old, "2"))
        print(norm(s - s.old, "2"))
        e = max(norm(v - v.old, "2"), norm(s - s.old, "2"))/q
        if (e < 1e-6 || k > maxiter){
            converged = TRUE
        }
    }
    return(list(v, s))}

##############################
## update_cols
##############################
#' @name update_cols
#'
#' @title subspace update based on projection of sample in question 
#' @description 
#' 
#' 
#'
#' @keywords internal
#' @param m.vec vector of GC corrected coverage data of sample in question
#' @param U the basis of low rank subspace
#' @param lambda1 tuning parameter
#' @param lambda2 tuning parameter
#' @return list with s and v vectors 

update_cols = function(U, A, B, lambda1){
    r = dim(U)[2]
    A = A + (lambda1 * diag(r))
    for (i in 1:r){
        bi = B[, i]
        ui = U[, i]
        ai = A[, i]
        numerator = ((bi - U %*% ai)/ A[i, i]) + ui
        U[, i] = numerator / max(norm(numerator, "2"), 1)
    }
    return(U)}



dc_machine = function(m.vec, L.burnin, S.burnin , r, N, U.hat, V.hat, sigma.hat, lambda1 = NA, lambda2 = NA, decomp = FALSE){
    if (decomp == TRUE){
        message("Starting decomposition, this will take a while!")
        rpca.N = rrpca(N, trace = TRUE)
        L.burnin = rpca.N$L
        r = rpca.N$k
        S.burnin = rpca.N$S
    }
    else{
        message("Using default set of normals a.k.a solvent")
        L.burnin = L.burnin
        r = r
        S.burnin = S.burnin
        U.hat = U.hat
        V.hat = V.hat
        sigma.hat = sigma.hat
    }
    m = dim(L.burnin)[1]
    n = dim(L.burnin)[2]
    if (is.na(lambda1)){
        lambda1 = 1/(sqrt(m))
        lambda2 = 100/(sqrt(m))
        message("lambdas calculated")
    }
    ## initialization
    message("And thus we begin the 'wash cycle'")
    U = U.hat %*% sqrt(diag(sigma.hat))
    A = matrix(0, r, r)
    B = matrix(0, m, r)
    message("calculating A and B")

    for (i in 1:dim(V.hat)[2]){
        A = A + outer(V.hat[, i], V.hat[, i])
        B = B + outer((L.burnin[, i] - S.burnin[, i]), V.hat[, i])
    }

    message("calculating L and S for sample in question")
    projection = apg_project(m.vec, U, lambda1, lambda2)
    vi = as.numeric(projection[[1]])
    si = as.numeric(projection[[2]])
    vi.subtract = V.hat[, 1]
    V.hat = cbind(V.hat, vi)
    A = A + outer(vi, vi) - outer(vi.subtract, vi.subtract)
    B = B + outer((as.numeric(m.vec) - si), vi) - outer((L.burnin[, 1] - S.burnin[, 1]), vi.subtract)
    message("Updating subspace")
    U = update_cols(U, A, B, lambda1)
    L.vec = U %*% vi
    return(list(L.vec, si))}



